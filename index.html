<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>死手加密系统 - DeadHand Cipher v4.2 [Final Fix]</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&family=Courier+Prime:wght@400;700&display=swap');
        
        body {
            font-family: 'Noto Sans SC', sans-serif;
            background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
            min-height: 100vh;
            color: #eaeaea;
        }
        
        .crypto-font {
            font-family: 'Courier Prime', monospace;
            letter-spacing: 0.05em;
        }
        
        .glyph-box {
            background: rgba(0,0,0,0.7);
            border: 1px solid #4a5568;
            transition: all 0.3s;
            font-size: 1.1rem;
        }
        
        .glyph-box:focus {
            border-color: #e53e3e;
            box-shadow: 0 0 20px rgba(229, 62, 62, 0.3);
            outline: none;
        }
        
        .btn-blood {
            background: linear-gradient(45deg, #e53e3e, #c53030);
            box-shadow: 0 4px 15px rgba(229, 62, 62, 0.4);
            transition: all 0.3s;
        }
        
        .btn-blood:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(229, 62, 62, 0.6);
        }
        
        .btn-ice {
            background: linear-gradient(45deg, #3182ce, #2c5282);
            box-shadow: 0 4px 15px rgba(49, 130, 206, 0.4);
            transition: all 0.3s;
        }
        
        .btn-ice:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(49, 130, 206, 0.6);
        }
        
        .cipher-text {
            color: #d6bcfa;
            text-shadow: 0 0 10px rgba(214, 188, 250, 0.3);
            font-weight: bold;
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <div class="max-w-5xl mx-auto">
        <div class="text-center mb-8">
            <h1 class="text-4xl md:text-5xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-red-400 to-purple-500" 
                style="filter: drop-shadow(0 0 10px rgba(229,62,62,0.5));">
                DEADHAND CIPHER v4.2
            </h1>
            <p class="text-gray-400 text-sm tracking-widest uppercase">Final Fix | 256 Unique Glyphs | Zero Ambiguity</p>
        </div>

        <div class="grid md:grid-cols-2 gap-6 mb-6">
            <div class="space-y-2">
                <label class="text-xs text-gray-500 uppercase tracking-widest flex justify-between items-center">
                    <span>Input [UTF-8]</span>
                    <button onclick="clearAll()" class="text-red-400 hover:text-red-300 text-xs underline">Clear</button>
                </label>
                <textarea id="inputArea" class="glyph-box w-full h-56 p-4 rounded-lg resize-none text-gray-200 crypto-font" 
                    placeholder="输入明文或密文..."></textarea>
                <div class="text-right text-xs text-gray-600">
                    <span id="inputBytes">0</span> chars
                </div>
            </div>

            <div class="space-y-2">
                <label class="text-xs text-gray-500 uppercase tracking-widest flex justify-between items-center">
                    <span>Output [Cipher]</span>
                    <button onclick="copyOutput()" class="text-blue-400 hover:text-blue-300 text-xs underline">Copy</button>
                </label>
                <textarea id="outputArea" readonly class="glyph-box w-full h-56 p-4 rounded-lg resize-none cipher-text crypto-font bg-black/80" 
                    placeholder="结果..."></textarea>
                <div class="text-right text-xs text-gray-600">
                    <span id="outputGlyphs">0</span> glyphs
                </div>
            </div>
        </div>

        <div class="mb-8 max-w-lg mx-auto">
            <label class="block text-center text-xs text-gray-500 mb-2 tracking-widest uppercase">Secret Key</label>
            <input type="text" id="keyInput" value="DeadHand2024" 
                class="glyph-box w-full px-6 py-3 rounded-full text-center text-gray-200 crypto-font text-lg">
        </div>

        <div class="flex flex-col sm:flex-row justify-center gap-4 mb-6">
            <button onclick="processEncrypt()" class="btn-blood text-white px-10 py-4 rounded-full font-bold text-lg flex items-center justify-center gap-2">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z"/></svg>
                ENCRYPT
            </button>
            <button onclick="processDecrypt()" class="btn-ice text-white px-10 py-4 rounded-full font-bold text-lg flex items-center justify-center gap-2">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 11V7a4 4 0 118 0m-4 8v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2z"/></svg>
                DECRYPT
            </button>
        </div>

        <div id="status" class="text-center text-sm h-8 font-bold tracking-wider"></div>
        
        <div class="mt-8 p-4 bg-black/40 rounded-lg border border-gray-800 text-xs text-gray-600 text-center">
            Char Set: Greek(0-63) + Cyrillic(64-127) + Hiragana(128-191) + Katakana(192-255)
        </div>
    </div>

    <script>
        /**
         * DeadHand Cipher v4.2 - Final Fix
         * 严格Unicode分区，确保无视觉相似字符混淆
         */

        // 生成256个唯一字符（4个区块，各64个）
        function generateGlyphSet() {
            const glyphs = [];
            
            // 0-63: 希腊字母扩展 (U+0391-U+03D6)
            for (let i = 0; i < 64; i++) {
                glyphs.push(String.fromCharCode(0x0391 + i));
            }
            
            // 64-127: 西里尔字母 (U+0410-U+044F，跳过U+0400-U+040F的扩展)
            for (let i = 0; i < 64; i++) {
                glyphs.push(String.fromCharCode(0x0410 + i));
            }
            
            // 128-191: 平假名 (U+3041-U+3080，常用清晰字符)
            for (let i = 0; i < 64; i++) {
                glyphs.push(String.fromCharCode(0x3041 + i));
            }
            
            // 192-255: 片假名 (U+30A1-U+30E0，常用清晰字符)
            for (let i = 0; i < 64; i++) {
                glyphs.push(String.fromCharCode(0x30A1 + i));
            }
            
            return glyphs;
        }

        const GLYPH_SET = generateGlyphSet();
        const REVERSE_MAP = new Map();
        GLYPH_SET.forEach((char, idx) => REVERSE_MAP.set(char, idx));

        // 验证
        console.log("Glyph set size:", GLYPH_SET.length); // 必须是256
        console.log("Unique check:", new Set(GLYPH_SET).size); // 必须是256

        function deriveKeyMaterial(keyStr) {
            let sBox = Array.from({length: 256}, (_, i) => i);
            const keyBytes = new TextEncoder().encode(keyStr);
            let j = 0;
            for (let i = 0; i < 256; i++) {
                j = (j + sBox[i] + keyBytes[i % keyBytes.length]) % 256;
                [sBox[i], sBox[j]] = [sBox[j], sBox[i]];
            }
            return sBox;
        }

        function createPRNG(sBox, keyStr) {
            let i = 0, j = 0;
            const keyBytes = new TextEncoder().encode(keyStr);
            let keyIdx = 0;
            return function() {
                i = (i + 1) % 256;
                j = (j + sBox[i] + keyBytes[keyIdx % keyBytes.length]) % 256;
                keyIdx++;
                [sBox[i], sBox[j]] = [sBox[j], sBox[i]];
                return sBox[(sBox[i] + sBox[j]) % 256];
            };
        }

        function processEncrypt() {
            const input = document.getElementById('inputArea').value;
            const key = document.getElementById('keyInput').value || 'default';
            
            if (!input) return showStatus('Please enter text', 'error');

            try {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(input);
                
                const sBox = deriveKeyMaterial(key);
                const getKeystreamByte = createPRNG([...sBox], key);
                
                const encrypted = new Uint8Array(bytes.length);
                for (let i = 0; i < bytes.length; i++) {
                    const substituted = sBox[bytes[i]];
                    encrypted[i] = substituted ^ getKeystreamByte();
                }
                
                let cipherText = '';
                for (let byte of encrypted) {
                    cipherText += GLYPH_SET[byte];
                }
                
                document.getElementById('outputArea').value = cipherText;
                document.getElementById('inputBytes').textContent = input.length;
                document.getElementById('outputGlyphs').textContent = cipherText.length;
                showStatus('ENCRYPTED SUCCESSFULLY', 'success');
                
            } catch (e) {
                showStatus('Error: ' + e.message, 'error');
            }
        }

        function processDecrypt() {
            const input = document.getElementById('inputArea').value;
            const key = document.getElementById('keyInput').value || 'default';
            
            if (!input) return showStatus('Please enter ciphertext', 'error');

            try {
                // 严格验证每个字符
                const encrypted = new Uint8Array(input.length);
                for (let i = 0; i < input.length; i++) {
                    const char = input[i];
                    const byte = REVERSE_MAP.get(char);
                    if (byte === undefined) {
                        // 显示具体的非法字符和Unicode码点，方便调试
                        const code = char.charCodeAt(0).toString(16).toUpperCase();
                        throw new Error(`Invalid glyph: "${char}" (U+${code})`);
                    }
                    encrypted[i] = byte;
                }
                
                const sBox = deriveKeyMaterial(key);
                const getKeystreamByte = createPRNG([...sBox], key);
                
                const invSBox = new Array(256);
                for (let i = 0; i < 256; i++) {
                    invSBox[sBox[i]] = i;
                }
                
                const decrypted = new Uint8Array(encrypted.length);
                for (let i = 0; i < encrypted.length; i++) {
                    const xorResult = encrypted[i] ^ getKeystreamByte();
                    decrypted[i] = invSBox[xorResult];
                }
                
                const decoder = new TextDecoder();
                const plain = decoder.decode(decrypted);
                
                document.getElementById('outputArea').value = plain;
                document.getElementById('inputBytes').textContent = input.length;
                document.getElementById('outputGlyphs').textContent = plain.length;
                showStatus('DECRYPTED SUCCESSFULLY', 'success');
                
            } catch (e) {
                showStatus(e.message, 'error');
                console.error(e);
            }
        }

        function clearAll() {
            document.getElementById('inputArea').value = '';
            document.getElementById('outputArea').value = '';
            document.getElementById('inputBytes').textContent = '0';
            document.getElementById('outputGlyphs').textContent = '0';
            showStatus('', 'clear');
        }

        function copyOutput() {
            const out = document.getElementById('outputArea');
            if (!out.value) return;
            out.select();
            document.execCommand('copy');
            showStatus('COPIED', 'success');
        }

        function showStatus(msg, type) {
            const stat = document.getElementById('status');
            stat.textContent = msg;
            if (type === 'error') {
                stat.className = 'text-center text-sm h-8 font-bold tracking-wider text-red-500';
            } else if (type === 'success') {
                stat.className = 'text-center text-sm h-8 font-bold tracking-wider text-green-400';
            } else {
                stat.className = 'text-center text-sm h-8 font-bold tracking-wider';
            }
            if (type !== 'clear') {
                setTimeout(() => { stat.textContent = ''; }, 3000);
            }
        }

        // 实时统计
        document.getElementById('inputArea').addEventListener('input', function() {
            document.getElementById('inputBytes').textContent = this.value.length;
        });
    </script>
</body>
</html>
